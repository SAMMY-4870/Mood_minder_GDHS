{% extends 'base.html' %}
{% block title %}Memory Match Â· Games{% endblock %}
{% block extra_css %}
<link href="{{ url_for('static', filename='css/pages/games.css') }}" rel="stylesheet">
<style>
.memory-game {
    max-width: 600px;
    margin: 0 auto;
    text-align: center;
}

.memory-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 10px;
    margin: 20px 0;
    max-width: 400px;
    margin-left: auto;
    margin-right: auto;
}

.memory-card {
    aspect-ratio: 1;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2rem;
    cursor: pointer;
    transition: all 0.3s ease;
    color: white;
    font-weight: bold;
}

.memory-card:hover {
    transform: scale(1.05);
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}

.memory-card.flipped {
    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    transform: rotateY(180deg);
}

.memory-card.matched {
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    cursor: default;
}

.memory-card.matched:hover {
    transform: none;
}

.game-stats {
    display: flex;
    justify-content: space-around;
    margin: 20px 0;
    padding: 15px;
    background: #f8f9fa;
    border-radius: 10px;
}

.stat-item {
    text-align: center;
}

.stat-value {
    font-size: 1.5rem;
    font-weight: bold;
    color: #6f42c1;
}

.stat-label {
    font-size: 0.9rem;
    color: #6c757d;
}

.game-controls {
    margin: 20px 0;
}

.btn-game {
    padding: 12px 30px;
    font-size: 1.1rem;
    border-radius: 25px;
    margin: 0 10px;
}

.focus-meter {
    width: 100%;
    height: 20px;
    background: #e9ecef;
    border-radius: 10px;
    overflow: hidden;
    margin: 20px 0;
}

.focus-bar {
    height: 100%;
    background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb, #0abde3);
    transition: width 0.3s ease;
    border-radius: 10px;
}

.completion-message {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    padding: 30px;
    border-radius: 15px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    text-align: center;
    z-index: 1000;
    display: none;
}

.overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    z-index: 999;
    display: none;
}
</style>
{% endblock %}

{% block content %}
<div class="memory-game">
    <h2 class="mb-4">ðŸ§  Memory Match</h2>
    <p class="lead">Match the pairs to improve your focus and memory!</p>
    
    <div class="game-stats">
        <div class="stat-item">
            <div class="stat-value" id="moves">0</div>
            <div class="stat-label">Moves</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="pairs">0</div>
            <div class="stat-label">Pairs Found</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="timer">0:00</div>
            <div class="stat-label">Time</div>
        </div>
    </div>
    
    <div class="focus-meter">
        <div class="focus-bar" id="focusBar" style="width: 0%"></div>
    </div>
    
    <div class="memory-grid" id="memoryGrid">
        <!-- Cards will be generated by JavaScript -->
    </div>
    
    <div class="game-controls">
        <button class="btn btn-primary btn-game" id="startBtn">Start Game</button>
        <button class="btn btn-secondary btn-game" id="resetBtn" disabled>Reset</button>
    </div>
    
    {% if stats %}
    <div class="mt-4">
        <h5>Your Statistics</h5>
        <div class="row text-center">
            <div class="col-md-3">
                <div class="stat-value">{{ stats.games_played or 0 }}</div>
                <div class="stat-label">Games Played</div>
            </div>
            <div class="col-md-3">
                <div class="stat-value">{{ stats.pairs_found or 0 }}</div>
                <div class="stat-label">Total Pairs</div>
            </div>
            <div class="col-md-3">
                <div class="stat-value">{{ stats.total_moves or 0 }}</div>
                <div class="stat-label">Total Moves</div>
            </div>
            <div class="col-md-3">
                <div class="stat-value">{{ (stats.total_time // 60) if stats.total_time else 0 }}m</div>
                <div class="stat-label">Total Time</div>
            </div>
        </div>
    </div>
    {% endif %}
</div>

<!-- Completion Modal -->
<div class="overlay" id="overlay"></div>
<div class="completion-message" id="completionMessage">
    <h3>ðŸŽ‰ Congratulations!</h3>
    <p id="completionText"></p>
    <button class="btn btn-primary" onclick="closeCompletion()">Play Again</button>
</div>

<script>
class MemoryGame {
    constructor() {
        this.cards = [];
        this.flippedCards = [];
        this.moves = 0;
        this.pairsFound = 0;
        this.startTime = null;
        this.timer = null;
        this.gameActive = false;
        this.symbols = ['ðŸŽ¯', 'ðŸŒŸ', 'ðŸŽ¨', 'ðŸŽª', 'ðŸŽ­', 'ðŸŽª', 'ðŸŽ¨', 'ðŸŒŸ', 'ðŸŽ¯', 'ðŸŽª', 'ðŸŽ­', 'ðŸŽ¨', 'ðŸŒŸ', 'ðŸŽ¯', 'ðŸŽª', 'ðŸŽ­'];
        this.reactionTimes = [];
        this.lastClickTime = null;
        
        this.init();
    }
    
    init() {
        this.shuffleCards();
        this.renderCards();
        this.bindEvents();
    }
    
    shuffleCards() {
        this.cards = [...this.symbols];
        for (let i = this.cards.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]];
        }
    }
    
    renderCards() {
        const grid = document.getElementById('memoryGrid');
        grid.innerHTML = '';
        
        this.cards.forEach((symbol, index) => {
            const card = document.createElement('div');
            card.className = 'memory-card';
            card.dataset.index = index;
            card.dataset.symbol = symbol;
            card.innerHTML = '?';
            grid.appendChild(card);
        });
    }
    
    bindEvents() {
        document.getElementById('startBtn').addEventListener('click', () => this.startGame());
        document.getElementById('resetBtn').addEventListener('click', () => this.resetGame());
        
        document.getElementById('memoryGrid').addEventListener('click', (e) => {
            if (e.target.classList.contains('memory-card') && this.gameActive) {
                this.handleCardClick(e.target);
            }
        });
    }
    
    startGame() {
        this.gameActive = true;
        this.startTime = Date.now();
        this.startTimer();
        document.getElementById('startBtn').disabled = true;
        document.getElementById('resetBtn').disabled = false;
    }
    
    startTimer() {
        this.timer = setInterval(() => {
            const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('timer').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }, 1000);
    }
    
    handleCardClick(card) {
        if (card.classList.contains('flipped') || card.classList.contains('matched')) {
            return;
        }
        
        // Record reaction time
        if (this.lastClickTime) {
            const reactionTime = Date.now() - this.lastClickTime;
            this.reactionTimes.push(reactionTime);
        }
        this.lastClickTime = Date.now();
        
        this.flipCard(card);
        this.flippedCards.push(card);
        
        if (this.flippedCards.length === 2) {
            this.moves++;
            document.getElementById('moves').textContent = this.moves;
            this.updateFocusScore();
            
            setTimeout(() => {
                this.checkMatch();
            }, 1000);
        }
    }
    
    flipCard(card) {
        card.classList.add('flipped');
        card.textContent = card.dataset.symbol;
    }
    
    checkMatch() {
        const [card1, card2] = this.flippedCards;
        
        if (card1.dataset.symbol === card2.dataset.symbol) {
            card1.classList.add('matched');
            card2.classList.add('matched');
            this.pairsFound++;
            document.getElementById('pairs').textContent = this.pairsFound;
            
            if (this.pairsFound === 8) {
                this.endGame();
            }
        } else {
            card1.classList.remove('flipped');
            card2.classList.remove('flipped');
            card1.textContent = '?';
            card2.textContent = '?';
        }
        
        this.flippedCards = [];
    }
    
    updateFocusScore() {
        const accuracy = this.pairsFound / this.moves;
        const avgReactionTime = this.reactionTimes.length > 0 ? 
            this.reactionTimes.reduce((a, b) => a + b, 0) / this.reactionTimes.length : 1000;
        
        // Calculate focus score (0-100)
        const reactionScore = Math.max(0, (2000 - avgReactionTime) / 2000);
        const focusScore = (accuracy * 0.4 + reactionScore * 0.3 + 0.3) * 100;
        
        document.getElementById('focusBar').style.width = `${Math.min(100, focusScore)}%`;
    }
    
    endGame() {
        this.gameActive = false;
        clearInterval(this.timer);
        
        const timeTaken = Math.floor((Date.now() - this.startTime) / 1000);
        const accuracy = this.pairsFound / this.moves;
        const avgReactionTime = this.reactionTimes.length > 0 ? 
            this.reactionTimes.reduce((a, b) => a + b, 0) / this.reactionTimes.length : 1000;
        
        // Show completion message
        document.getElementById('completionText').innerHTML = `
            <p>You completed the game in ${this.moves} moves!</p>
            <p>Time: ${Math.floor(timeTaken / 60)}:${(timeTaken % 60).toString().padStart(2, '0')}</p>
            <p>Accuracy: ${(accuracy * 100).toFixed(1)}%</p>
            <p>Average Reaction Time: ${avgReactionTime.toFixed(0)}ms</p>
        `;
        
        document.getElementById('overlay').style.display = 'block';
        document.getElementById('completionMessage').style.display = 'block';
        
        // Submit results to server
        this.submitResults(timeTaken, accuracy, avgReactionTime);
    }
    
    submitResults(timeTaken, accuracy, avgReactionTime) {
        const formData = new FormData();
        formData.append('action', 'complete_game');
        formData.append('moves', this.moves);
        formData.append('time_taken', timeTaken);
        formData.append('pairs_found', this.pairsFound);
        formData.append('accuracy', accuracy);
        formData.append('avg_reaction_time', avgReactionTime);
        formData.append('consistency', 0.8); // Placeholder consistency score
        
        fetch(window.location.href, {
            method: 'POST',
            body: formData
        }).then(response => {
            if (response.ok) {
                location.reload(); // Reload to show updated stats
            }
        });
    }
    
    resetGame() {
        this.gameActive = false;
        this.moves = 0;
        this.pairsFound = 0;
        this.flippedCards = [];
        this.reactionTimes = [];
        this.lastClickTime = null;
        
        clearInterval(this.timer);
        document.getElementById('timer').textContent = '0:00';
        document.getElementById('moves').textContent = '0';
        document.getElementById('pairs').textContent = '0';
        document.getElementById('focusBar').style.width = '0%';
        
        document.getElementById('startBtn').disabled = false;
        document.getElementById('resetBtn').disabled = true;
        
        this.shuffleCards();
        this.renderCards();
    }
}

function closeCompletion() {
    document.getElementById('overlay').style.display = 'none';
    document.getElementById('completionMessage').style.display = 'none';
}

// Initialize game when page loads
document.addEventListener('DOMContentLoaded', () => {
    new MemoryGame();
});
</script>
{% endblock %}
